{% macro idOrSynonim(component) %}{# if no Synonim in yTranslator, than use id #}
{%- if yTranslator.symbolName[component.id] -%}
{{ yTranslator.symbolName[component.id] }}
{%- else -%}
{{ component.id }}
{%- endif -%}
{% endmacro -%}
{#-
  constants : all constants
  initRecords : all records SORTED by start_ and have start_ or isRule
  dynamicRecords : records with isDynamic = true, i.e. no rules, no boundary, have reactions
  ruleRecords : all records SORTED by ode_
  staticRecords : records which is not dynamic nor rule
  events : array of {switcher, array of assignments with [switcher]}
-#}

#= 
    This code was generated by {{ builderName }}
    {{ options.title + '.' if options.title}}{{ options.notes }}
=#

module {{ options.id }}
using SimSolver

### create default constants
constants_ = NamedTuple{(
  {% for con in constants -%}
    :{{ con.id }}, 
  {%- endfor %}
)}(Float64[
  {% for con in constants -%}
    {{ con.num }},
  {%- endfor %}
])

### initialization of ODE variables and Records
function start_(cons)
    #({% for con in constants -%}
    {{ con.id }}, 
    {%- endfor %}) = cons

    # Heta initialize
    t = 0.0 # initial time
    {% for record in initRecords -%}
    {% if record.getAssignment('start_') is defined -%}
    {{ record.id }} = {{ record.getAssignment('start_').translate(pTranslator).toJuliaString() }}
    {%- else -%}
    {{ record.id }} = {{ record.getAssignment('ode_').translate(pTranslator).toJuliaString() }}
    {%- endif %}
    {% endfor %}
    # save results

    return (
        {%- if dynamicRecords|length > 0 %}
        [
        {%- for record in dynamicRecords %}
        {%- if record.instanceOf('Species') and not record.isAmount and not record.isRule %}
            {{ record.id }} * {{ record.compartment }}, 
        {%- else %}
            {{ record.id }}, 
        {%- endif %}
        {%- endfor %}
        ],
        {% else %}
        [ 0.0 ], # init for fake variable
        {%- endif %}
        [
        {%- for record in staticRecords %}
            {{ record.id }}, 
        {%- endfor %}
        ]
    )
end

### calculate RHS of ODE
function ode_(du, u, p, t)
    cons = p.constants
    ({% for record in staticRecords -%}
    {{ record.id }}, 
    {%- endfor %}) = p.static
    ({% for record in dynamicRecords -%}
    {{ record.id }}_, 
    {%- endfor %}) = u {# TODO: replace by u[index] #}

    # Heta rules
    {% for record in ruleRecords %}
    {%- if record.isRule -%}
    {{ record.id }} = {{ record.assignments.ode_.translate(pTranslator).toJuliaString() }}
    {% elif record.instanceOf('Species') and record.isDynamic and not record.isAmount -%}
    {{ record.id }} = {{ record.id }}_ / {{ record.compartment }}
    {% elif record.isDynamic -%}
    {{ record.id }} = {{ record.id }}_
    {% endif -%}
    {% endfor %}
    #p.static .= [{% for record in staticRecords -%}
    {{ record.id }}, 
    {%- endfor %}]
    {%- if dynamicRecords|length > 0 %}
    du .= [{% for record in dynamicRecords %}
      {{ rhs[loop.index0] }},  # d{{ record.id }}_/dt
    {%- endfor %}
    ]
    {%- else %}
    du .= [ 1.0 ] # RHS for fake variable
    {%- endif %}
end

### output function
function make_saving_(outputIds::Vector{Symbol})
    function saving_(u, t, integrator)
        cons = integrator.p.constants
        ({% for record in staticRecords -%}
        {{ record.id }}, 
        {%- endfor %}) = integrator.p.static
        ({% for record in dynamicRecords -%}
        {{ record.id }}_, 
        {%- endfor %}) = u{# TODO: replace by u[index] #}

        # Heta rules
        {% for record in ruleRecords %}
        {%- if record.isRule -%}
        {{ record.id }} = {{ record.assignments.ode_.translate(pTranslator).toJuliaString() }}
        {% elif record.instanceOf('Species') and record.isDynamic and not record.isAmount -%}
        {{ record.id }} = {{ record.id }}_ / {{ record.compartment }}
        {% elif record.isDynamic -%}
        {{ record.id }} = {{ record.id }}_
        {% endif -%}
        {% endfor %}
        # calculate amounts
        {%- for record in notDynamicRecords %}
        {%- if record.instanceOf('Species') and not record.isAmount %}
        {{ record.id }}_ = {{ record.id }} * {{ record.compartment }}
        {%- else %}
        {{ record.id }}_ = {{ record.id }}
        {%- endif %}
        {%- endfor %}

        d = Base.@locals
        return [d[id] for id in outputIds]
    end
end

### events
{% for event in events -%}
function {{event.switcher.id}}_condition_(u, t, integrator)
    cons = integrator.p.constants
    ({% for record in staticRecords -%}
    {{ record.id }}, 
    {%- endfor %}) = integrator.p.static
    ({% for record in dynamicRecords -%}
    {{ record.id }}_, 
    {%- endfor %}) = u

    # Heta rules
    {% for record in ruleRecords %}
    {%- if record.isRule -%}
    {{ record.id }} = {{ record.assignments.ode_.translate(pTranslator).toJuliaString() }}
    {% elif record.instanceOf('Species') and record.isDynamic and not record.isAmount -%}
    {{ record.id }} = {{ record.id }}_ / {{ record.compartment }}
    {% elif record.isDynamic -%}
    {{ record.id }} = {{ record.id }}_
    {% endif -%}
    {% endfor %}

    {%- if event.switcher.instanceOf('TimeSwitcher') %}
    {%- set ev_start = event.switcher.getStart() if event.switcher.startObj.num is defined else '0.0' %}
    {%- set ev_period = event.switcher.getPeriod() if event.switcher.periodObj.num is defined else '0.0' %}
    {%- set ev_repeatCount = event.switcher.getRepeatCount() if event.switcher.repeatCountObj.num is defined else 'Inf' %}
    function flag_(t)
        flag_ = (t - {{ ev_start }})/{{ ev_period }};
        
        if flag_ <= 0.
            res_ = flag_
        elseif 0. < flag_ && flag_ < {{ ev_repeatCount }}
            res_ = flag_ - floor(flag_ + 0.5)
        else
            res_ = flag_ - {{ ev_repeatCount }}
        end
        return res_
    end

    return flag_(t)
    {%- elif event.switcher.instanceOf('CondSwitcher') %}
    return {{ event.switcher.condition }}
    {%- endif %}
end

function {{event.switcher.id}}_assignment_(integrator)
    cons = integrator.p.constants
    t = integrator.t
    ({% for record in staticRecords -%}
    {{ record.id }}, 
    {%- endfor %}) = integrator.p.static
    ({% for record in dynamicRecords -%}
    {{ record.id }}_, 
    {%- endfor %}) = integrator.u

    # Heta rules
    {% for record in ruleRecords %}
    {%- if record.isRule -%}
    {{ record.id }} = {{ record.assignments.ode_.translate(pTranslator).toJuliaString() }}
    {% elif record.instanceOf('Species') and record.isDynamic and not record.isAmount -%}
    {{ record.id }} = {{ record.id }}_ / {{ record.compartment }}
    {% elif record.isDynamic -%}
    {{ record.id }} = {{ record.id }}_
    {% endif -%}
    {% endfor %}
    # recalculated values
    ({%- for assignment in event.affect -%}
    {{ assignment.id }}, 
    {%- endfor %}) = ({%- for assignment in event.affect -%}
    {{ assignment.getAssignment(event.switcher.id).translate(pTranslator).toJuliaString() }}, 
    {%- endfor %})
    
    # save results

    integrator.u .= [{% for record in dynamicRecords %}
    {%- if record.instanceOf('Species') and not record.isAmount and not record.isRule %}
        {{ record.id }} * {{ record.compartment }}, 
    {%- else %}
        {{ record.id }}, 
    {%- endif %}
    {%- endfor %}
    ]
    
    integrator.p.static .= [{% for record in staticRecords -%}
    {{ record.id }}, 
    {%- endfor %}]
end
{% endfor %}

### OUTPUT ###

{{namespace.spaceName}} = Model(
  start_,
  ode_,
  [{% for event in events %}({{event.switcher.id}}_condition_, {{event.switcher.id}}_assignment_), {% endfor %}],
  make_saving_,
  constants_
)

models = (
    {{namespace.spaceName}} = {{namespace.spaceName}}
)
tasks = ()

export models, tasks

end
