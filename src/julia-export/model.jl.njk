{% macro idOrSynonim(component) %}{# if no Synonim in yTranslator, than use id #}
{%- if yTranslator.symbolName[component.id] -%}
{{ yTranslator.symbolName[component.id] }}
{%- else -%}
{{ component.id }}
{%- endif -%}
{% endmacro -%}

#= 
    This code was generated by {{ builderName }}
    {{ options.title + '.' if options.title}}{{ options.notes }}
=#

module {{ options.id }}
using SimSolver

# create default constants
constants_ = ({% for con in constants %}
    {{ con.id }} = {{ con.num }}{{ ', ' if not loop.last }}
{%- endfor %}
)

# initialization of ODE variables and Records
function start_(constants)
    ({% for con in constants -%}
    {{ con.id }}{{ ', ' if not loop.last }}
    {%- endfor %}) = constants

    # Heta initialize
    {% for record in initRecords -%}
    {{ record.id }} = {{ record.getAssignment('start_').toJuliaString() if record.getAssignment('start_') is defined else 'missing' }}
    {% endfor %}
    # transform to ODE variables
    {% for record in dynamicRecords -%}
    {% if record.instanceOf('Species') and not record.isAmount and not record.implicitBoundary -%}
    {{ record.id }}_ = {{ record.id }} * {{ record.compartment }}
    {% else -%}
    {{ record.id }}_ = {{ record.id }}
    {% endif %}
    {%- endfor %}
    return (
        [{% for record in dynamicRecords -%}
        {{ record.id }}_{{ ', ' if not loop.last }}
        {%- endfor %}],
        [{% for record in namespace.selectByInstanceOf('Record') -%}
        {{ record.id }}{{ ', ' if not loop.last }}
        {%- endfor %}]
    )
end

# calculate RHS of ODE
function ode_(du, u, p, t)
    ({% for con in constants -%}
    {{ con.id }}{{ ', ' if not loop.last }}
    {%- endfor %}) = p.constants
    ({% for record in namespace.selectByInstanceOf('Record') -%}
    {{ record.id }}{{ ', ' if not loop.last }}
    {%- endfor %}) = p.static
    ({% for record in dynamicRecords -%}
    {{ record.id }}_{{ ', ' if not loop.last }}
    {%- endfor %}) = u

    # Heta rules
    {% for record in outputRecords %}
    {%- if record.implicitBoundary -%}
    {{ record.id }} = {{ record.assignments.ode_.toJuliaString() }}
    {% elif record.instanceOf('Species') and record.isDynamic and not record.isAmount -%}
    {{ record.id }} = {{ record.id }}_ / {{ record.compartment }}
    {% elif record.isDynamic -%}
    {{ record.id }} = {{ record.id }}_
    {% endif -%}
    {% endfor %}

    #p.static .= [{% for record in namespace.selectByInstanceOf('Record') -%}
    {{ record.id }}{{ ', ' if not loop.last }}
    {%- endfor %}]
    du = [{% for record in dynamicRecords %}
      {{ rhs[loop.index0] }}{{ ', ' if not loop.last}} # d{{ record.id }}_/dt
    {%- endfor %}
    ]
end

# output function
function make_saving_(outputIds::Vector{Symbol})
    function saving_(u, t, integrator)
        ({% for con in constants -%}
        {{ con.id }}{{ ', ' if not loop.last }}
        {%- endfor %}) = integrator.p.constants
        ({% for record in namespace.selectByInstanceOf('Record') -%}
        {{ record.id }}{{ ', ' if not loop.last }}
        {%- endfor %}) = integrator.p.static
        ({% for record in dynamicRecords -%}
        {{ record.id }}_{{ ', ' if not loop.last }}
        {%- endfor %}) = u

        # Heta rules
        {% for record in outputRecords %}
        {%- if record.implicitBoundary -%}
        {{ record.id }} = {{ record.assignments.ode_.toJuliaString() }}
        {% elif record.instanceOf('Species') and record.isDynamic and not record.isAmount -%}
        {{ record.id }} = {{ record.id }}_ / {{ record.compartment }}
        {% elif record.isDynamic -%}
        {{ record.id }} = {{ record.id }}_
        {% endif -%}
        {% endfor %}
        d = Base.@locals
        return [d[id] for id in outputIds]
    end
end

{{namespace.spaceName}} = Model(
  start_,
  ode_,
  [],
  make_saving_,
  constants_
)

### OUTPUT ###

models = (
    {{namespace.spaceName}} = {{namespace.spaceName}}
)

#=
function [out_func, events_] = {{ options.id }}_Model(p)

    {% for event in events -%}
    function [res, isterminal, direction] = {{ event.switcher.id }}_condition(t, y)
        direction = 1; % [];
        isterminal = 1;
        
        ev_start = {{ event.switcher.startObj.num }};
        ev_period = {{ event.switcher.periodObj.num if event.switcher.periodObj.num is defined else '[]'}};
        ev_repeatCount = {{ event.switcher.getRepeatCountInt() }};
        
        flag = (t - ev_start)/ev_period;
        
        if flag <= 0.
            res = flag;
        elseif (0. < flag) && (flag < ev_repeatCount)
            res = flag - floor(flag + 0.5);
        else
            res = flag - ev_repeatCount;
        end
    end
    function y = {{ event.switcher.id }}_affect(t, y)

        %%% Records
        {%- for record in outputRecords %}
        % {{ record.title }} ({{ record.units }}) {{ record.notes }}
        {% if record.implicitBoundary -%}
        {{ record.id }} = {{ record.assignments.ode_.translate(pTranslator).toMatlabString() }};
        {%- elif record.instanceOf('Species') and not record.isAmount -%}
        {{ record.id }} = {{ yTranslator.symbolName[record.id] }} / {{ record.compartment }};
        {%- else -%}
        {{ record.id }} = {{ yTranslator.symbolName[record.id] }};
        {%- endif -%}
        {%- endfor %}
        
        %%% recalculated values
        {%- for assignment in event.affect %}
        {% if assignment.instanceOf('Species') and not assignment.isAmount and not assignment.implicitBoundary -%}
        {{ idOrSynonim(assignment) }} = ({{ assignment.getAssignment(event.switcher.id).translate(pTranslator).toMatlabString() }}) * {{ assignment.compartment }};
        {%- else -%}
        {{ idOrSynonim(assignment) }} = {{ assignment.getAssignment(event.switcher.id).translate(pTranslator).toMatlabString() }};
        {%- endif -%}
        {%- endfor %}
        
    end
    {{ event.switcher.id }}_ = { @{{ event.switcher.id }}_condition, @{{ event.switcher.id }}_affect };
    {%- endfor %}

    events_ = [
    {%- for event in events %}{{ event.switcher.id }}_{{ ', ' if not loop.last }}{% endfor -%}
    ];
end
=#