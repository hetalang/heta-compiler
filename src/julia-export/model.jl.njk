{% macro idOrSynonim(component) %}{# if no Synonim in yTranslator, than use id #}
{%- if yTranslator.symbolName[component.id] -%}
{{ yTranslator.symbolName[component.id] }}
{%- else -%}
{{ component.id }}
{%- endif -%}
{% endmacro -%}
{#-
  constants : all constants
  initRecords : all records SORTED by start_
  dynamicRecords : all records with isDynamic = true, i.e. no rules, no boundary, have reactions
  ruleRecords : all records SORTED by ode_
  events : array of {switcher, array of assignments with [switcher]}
-#}

#= 
    This code was generated by {{ builderName }}
    {{ options.title + '.' if options.title}}{{ options.notes }}
=#

module {{ options.id }}
using SimSolver

### create default constants
constants_ = ({% for con in constants %}
    {{ con.id }} = Float64({{ con.num }}){{ ', ' if not loop.last }}
{%- endfor %}
)

### initialization of ODE variables and Records
function start_(constants)
    ({% for con in constants -%}
    {{ con.id }}{{ ', ' if not loop.last }}
    {%- endfor %}) = constants

    # Heta initialize
    {% for record in initRecords -%}
    {{ record.id }} = {{ record.getAssignment('start_').toJuliaString() if record.getAssignment('start_') is defined else 'missing' }}
    {% endfor %}
    # save results
    
    u__ = [{% for record in dynamicRecords %}
    {%- if record.instanceOf('Species') and not record.isAmount and not record.implicitBoundary %}
        {{ record.id }} * {{ record.compartment }}{{ ', ' if not loop.last}}
    {%- else %}
        {{ record.id }}{{ ', ' if not loop.last}}
    {%- endif %}
    {%- endfor %}
    ]

    return (
        u__,
        [{% for record in namespace.selectByInstanceOf('Record') -%}
        {{ record.id }}{{ ', ' if not loop.last }}
        {%- endfor %}]
    )
end

### calculate RHS of ODE
function ode_(du, u, p, t)
    ({% for con in constants -%}
    {{ con.id }}{{ ', ' if not loop.last }}
    {%- endfor %}) = p.constants
    ({% for record in namespace.selectByInstanceOf('Record') -%}
    {{ record.id }}{{ ', ' if not loop.last }}
    {%- endfor %}) = p.static
    ({% for record in dynamicRecords -%}
    {{ record.id }}_{{ ', ' if not loop.last }}
    {%- endfor %}) = u {# TODO: replace by u[index] #}

    # Heta rules
    {% for record in ruleRecords %}
    {%- if record.implicitBoundary -%}
    {{ record.id }} = {{ record.assignments.ode_.toJuliaString() }}
    {% elif record.instanceOf('Species') and record.isDynamic and not record.isAmount -%}
    {{ record.id }} = {{ record.id }}_ / {{ record.compartment }}
    {% elif record.isDynamic -%}
    {{ record.id }} = {{ record.id }}_
    {% endif -%}
    {% endfor %}

    #p.static .= [{% for record in namespace.selectByInstanceOf('Record') -%}
    {{ record.id }}{{ ', ' if not loop.last }}
    {%- endfor %}]
    du .= [{% for record in dynamicRecords %}
      {{ rhs[loop.index0] }}{{ ', ' if not loop.last}} # d{{ record.id }}_/dt
    {%- endfor %}
    ]
end

### output function
function make_saving_(outputIds::Vector{Symbol})
    function saving_(u, t, integrator)
        ({% for con in constants -%}
        {{ con.id }}{{ ', ' if not loop.last }}
        {%- endfor %}) = integrator.p.constants
        ({% for record in namespace.selectByInstanceOf('Record') -%}
        {{ record.id }}{{ ', ' if not loop.last }}
        {%- endfor %}) = integrator.p.static
        ({% for record in dynamicRecords -%}
        {{ record.id }}_{{ ', ' if not loop.last }}
        {%- endfor %}) = u{# TODO: replace by u[index] #}

        # Heta rules
        {% for record in ruleRecords %}
        {%- if record.implicitBoundary -%}
        {{ record.id }} = {{ record.assignments.ode_.toJuliaString() }}
        {% elif record.instanceOf('Species') and record.isDynamic and not record.isAmount -%}
        {{ record.id }} = {{ record.id }}_ / {{ record.compartment }}
        {% elif record.isDynamic -%}
        {{ record.id }} = {{ record.id }}_
        {% endif -%}
        {% endfor %}
        d = Base.@locals
        return [d[id] for id in outputIds]
    end
end

### events
{% for event in events -%}
function {{event.switcher.id}}_condition_(u, t, integrator)
    ({% for con in constants -%}
    {{ con.id }}{{ ', ' if not loop.last }}
    {%- endfor %}) = integrator.p.constants
    ({% for record in namespace.selectByInstanceOf('Record') -%}
    {{ record.id }}{{ ', ' if not loop.last }}
    {%- endfor %}) = integrator.p.static
    ({% for record in dynamicRecords -%}
    {{ record.id }}_{{ ', ' if not loop.last }}
    {%- endfor %}) = u

    # Heta rules
    {% for record in ruleRecords %}
    {%- if record.implicitBoundary -%}
    {{ record.id }} = {{ record.assignments.ode_.toJuliaString() }}
    {% elif record.instanceOf('Species') and record.isDynamic and not record.isAmount -%}
    {{ record.id }} = {{ record.id }}_ / {{ record.compartment }}
    {% elif record.isDynamic -%}
    {{ record.id }} = {{ record.id }}_
    {% endif -%}
    {% endfor %}

    {%- set ev_start = event.switcher.getStart() if event.switcher.startObj.num is defined else '0.0' %}
    {%- set ev_period = event.switcher.getPeriod() if event.switcher.periodObj.num is defined else '0.0' %}
    {%- set ev_repeatCount = event.switcher.getRepeatCount() if event.switcher.repeatCountObj.num is defined else 'Inf' %}
    function flag_(t)
        flag_ = (t - {{ ev_start }})/{{ ev_period }};
        
        if flag_ <= 0.
            res_ = flag_
        elseif 0. < flag_ & flag_ < {{ ev_repeatCount }}
            res_ = flag_ - floor(flag_ + 0.5)
        else
            res_ = flag_ - {{ ev_repeatCount }}
        end
        return res_
    end

    return flag_(t)
end

function {{event.switcher.id}}_assignment_(integrator)
    save_position(integrator)
    ({% for con in constants -%}
    {{ con.id }}{{ ', ' if not loop.last }}
    {%- endfor %}) = integrator.p.constants
    ({% for record in namespace.selectByInstanceOf('Record') -%}
    {{ record.id }}{{ ', ' if not loop.last }}
    {%- endfor %}) = integrator.p.static
    ({% for record in dynamicRecords -%}
    {{ record.id }}_{{ ', ' if not loop.last }}
    {%- endfor %}) = integrator.u

    # Heta rules
    {% for record in ruleRecords %}
    {%- if record.implicitBoundary -%}
    {{ record.id }} = {{ record.assignments.ode_.toJuliaString() }}
    {% elif record.instanceOf('Species') and record.isDynamic and not record.isAmount -%}
    {{ record.id }} = {{ record.id }}_ / {{ record.compartment }}
    {% elif record.isDynamic -%}
    {{ record.id }} = {{ record.id }}_
    {% endif -%}
    {% endfor %}
    # recalculated values
    ({%- for assignment in event.affect -%}
    {{ assignment.id }}{{ ', ' if not loop.last }}
    {%- endfor %}) = ({%- for assignment in event.affect -%}
    {{ assignment.getAssignment(event.switcher.id).toJuliaString() }}{{ ', ' if not loop.last }}
    {%- endfor %})
    
    # save results

    integrator.u .= [{% for record in dynamicRecords %}
    {%- if record.instanceOf('Species') and not record.isAmount and not record.implicitBoundary %}
        {{ record.id }} * {{ record.compartment }}{{ ', ' if not loop.last}}
    {%- else %}
        {{ record.id }}{{ ', ' if not loop.last}}
    {%- endif %}
    {%- endfor %}
    ]
    
    integrator.p.static .= [{% for record in namespace.selectByInstanceOf('Record') -%}
    {{ record.id }}{{ ', ' if not loop.last }}
    {%- endfor %}]
    save_position(integrator)
end
{% endfor %}

### OUTPUT ###

{{namespace.spaceName}} = Model(
  start_,
  ode_,
  [{% for event in events %}({{event.switcher.id}}_condition_, {{event.switcher.id}}_assignment_){{ ', ' if not loop.last}}{% endfor %}],
  make_saving_,
  constants_
)

models = (
    {{namespace.spaceName}} = {{namespace.spaceName}}
)
tasks = ()

export models, tasks

end
